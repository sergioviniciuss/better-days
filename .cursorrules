You are a senior full stack engineer working on this codebase.

# Code Style Rules

## Frontend

### Functions
- Always use arrow functions instead of function declarations
- Prefer concise, readable function expressions

### Typescript
- Never use one-letter type names (e.g., avoid `T`, `U`, `K` - use descriptive names like `UserData`, `ApiResponse`)
- Avoid using   `any` type - use proper types or `unknown` when necessary
- Use descriptive, meaningful type names that clearly indicate their purpose
- avoid overengineering types

### JSX react
- Prefer ternary operators over `&&` syntax for conditional rendering
 - good: `{isVisible ? <Component /> : null}`
 - bad: `{isVisible && <Component />}`
- Use ternary for explicit null/undefined handling

### Next.js hooks and Context
- Avoid using `useParams()` in client components that render from server components - it can fail during SSR with "Cannot read properties of null (reading 'useContext')" errors
- Prefer parsing `usePathname()` for route params instead of `useParams()` when possible
- Example: `const locale = pathname.split('/')[1]` is more reliable than `const params = useParams(); const locale = params?.locale`
- Only use `useParams()` when absolutely necessary and in components that are guaranteed to be in the proper Next.js router context

### Testing
- Prefer `screen` queries over container queries
- prefer toBeVisible instead of ToBeInTheDocument when possible
- write tests that resemble how users use the app
- avoid mocking unless unavoidable
- use both unit and integration tests: unit tests for pure logic and contracts, integration tests for UI behavior and user flows
- avoid snapshot testing for logic

### Formatting
- Do NOT add trailing empty lines at the end of files
- Files should end with a single newline character (if any)
- Do NOT add extra whitespace or empty lines unless necessary for readability
- Preserve existing formatting unless explicitly asked to reformat
- When making changes, only modify what's necessary - don't reformat unrelated code

# Database Setup

- Database is hosted on Supabase and is NOT accessible locally
- Do NOT attempt to run `npx prisma migrate dev` or any local Prisma migrations
- When database schema changes are needed:
  1. Update `prisma/schema.prisma` with the new schema
  2. Create a `.sql` migration file (e.g., `add-feature-name.sql`) in the project root
  3. Write the SQL DDL statements that need to be run on Supabase
  4. Instruct the user to run the SQL script in the Supabase SQL Editor
  5. Include comments in the SQL to explain what each statement does
- Always ensure migrations are backward compatible with existing data
- Use DEFAULT values when adding new NOT NULL columns to existing tables

# Async Actions Pattern

When implementing async actions that involve navigation or state changes:

1. **Loading States**: Always add loading/pending state to buttons/UI elements
   - Use `useState` for simple async operations with loading feedback
   - Use `useTransition` for React transitions that don't need explicit loading state
   - Disable interactive elements during pending state
   - Show visual feedback (loading text, spinner, etc.)

2. **Navigation After Async Actions**:
   - Use `router.push()` or `router.refresh()` for client-side navigation
   - Use `window.location.href` only when session/cookie establishment is critical (e.g., login/logout)
   - Add delays (`await new Promise(resolve => setTimeout(resolve, 300))`) before redirects when session establishment is needed

3. **Error Handling**: Always handle and display errors from async operations
   - Store error state in component state
   - Display error messages clearly to users
   - Keep UI interactive (don't leave in loading state on error)

4. **Examples**:
   - Login/Signup: `window.location.href` with 300ms delay (session critical)
   - Form submissions: `router.refresh()` after successful mutation
   - Client-side navigation: `router.push()` with loading state
   - Banner actions: Loading state on buttons, `router.push()` for navigation


# General principles

- Consider performance implications
- Write clean, maintainable code
- Follow existing patterns in the code base
- Consider edge cases and error handling
- Keep functions focused and single-purpose
- prefer simple, boring solutions over clever abstractions
- avoid premature optimization
- make code easy to delete
- Prefer explicit over implicit
- Colocate related code
- Prefer tailwind classes over custom CSS
- Make sure user feedback is provided when navigating or waiting for async actions
- Use mobile-first approach
- this project uses yarn as package manager